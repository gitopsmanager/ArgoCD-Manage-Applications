name: "ArgoCD Manage Applications"
description: "Handles full ArgoCD lifecycle: auth, connect, delete, create, sync, wait-for-sync. Supports no-fail mode for restore cluster runs."

inputs:
  argocd_url:
    description: "Full ArgoCD base URL (e.g. https://aks-prod-weu-argocd-argocd-web-ui.affinity7software.com)"
    required: true
    type: string

  argocd_auth_token:
    required: false
    type: string

  argocd_username:
    required: false
    type: string

  argocd_password:
    required: false
    type: string

  insecure_argo:
    required: false
    default: false
    type: string

  argocd_ca_cert:
    required: false
    type: string

  namespace:
    required: true
    type: string

  cd_repo:
    required: true
    type: string

  cd_path_rel:
    description: "Relative path inside the CD repo where app files were copied (e.g. <cluster>/<namespace>)"
    required: true
    type: string

  cd_repo_org:
    required: true
    type: string

  overlay_dir:
    required: false
    default: ""
    type: string

  apps:
    description: "JSON array of {name, path, images}"
    required: true
    type: string

  delete_first:
    required: false
    default: false
    type: string

  delete_only:
    required: false
    default: false
    type: string

  skip_status_check:
    required: false
    default: false
    type: string

 

runs:
  using: composite


  steps:

    - name: Verify delete_only type
      run: |
        echo "delete_only raw  : '${{ inputs.delete_only }}'"
        echo "Expression result: ${{ inputs.delete_only == 'false' }}"
      shell: bash



    - name: Resolve ArgoCD auth
      id: resolve_auth
      shell: bash
      env:
        IN_TOKEN: ${{ inputs.argocd_auth_token }}
        IN_USER: ${{ inputs.argocd_username }}
        IN_PASS: ${{ inputs.argocd_password }}
      run: |
        set -euo pipefail
        if [ -n "${IN_TOKEN:-}" ]; then
          echo "mode=token" >> "$GITHUB_OUTPUT"
          echo "token=$IN_TOKEN" >> "$GITHUB_OUTPUT"
        elif [ -n "${IN_USER:-}" ] && [ -n "${IN_PASS:-}" ]; then
          echo "mode=basic" >> "$GITHUB_OUTPUT"
          echo "username=$IN_USER" >> "$GITHUB_OUTPUT"
          echo "password=$IN_PASS" >> "$GITHUB_OUTPUT"
        elif [ -n "${SEC_USER:-}" ] && [ -n "${SEC_PASS:-}" ]; then
          echo "mode=basic" >> "$GITHUB_OUTPUT"
          echo "username=$SEC_USER" >> "$GITHUB_OUTPUT"
          echo "password=$SEC_PASS" >> "$GITHUB_OUTPUT"
        else
          echo "‚ùå No ArgoCD auth provided."
          exit 1
        fi

    - name: Debug ARGOCD_CA_CERT presence
      run: |
        if [ -z "${ARGOCD_CA_CERT}" ]; then
          echo "‚ùå ARGOCD_CA_CERT is not set"
        else
          echo "‚úÖ ARGOCD_CA_CERT is set (length: ${#ARGOCD_CA_CERT})"
        fi
      shell: bash
      env:
        ARGOCD_CA_CERT: ${{ inputs.argocd_ca_cert }}

    - name: Set ArgoCD connection (token & URLs)
      id: argocd_conn
      uses: actions/github-script@v7
      env:
        ARGOCD_URL: ${{ inputs.argocd_url }}
        MODE: ${{ steps.resolve_auth.outputs.mode }}
        TOKEN: ${{ steps.resolve_auth.outputs.token }}
        USERNAME: ${{ steps.resolve_auth.outputs.username }}
        PASSWORD: ${{ steps.resolve_auth.outputs.password }}
        ARGOCD_CA_CERT: ${{ inputs.argocd_ca_cert }}
        CLUSTER: ${{ github.event.inputs.target_cluster || github.event.inputs.cluster }}
        DNS_ZONE: ${{ github.event.inputs.dns_zone }}
        INSECURE_ARGO: ${{ inputs.insecure_argo }}
      with:
        script: |
          const { execSync } = require('child_process');
          const fs = require('fs');
          const argocdUrl = process.env.ARGOCD_URL;
          if (!argocdUrl) {
            core.setFailed("‚ùå Missing required input: argocd_url");
            return;
          }


          let curlSslFlags = "";
          if (String(process.env.INSECURE_ARGO) === "true") {
            curlSslFlags = "-k";
            core.warning("‚ö†Ô∏è Using insecure connection (curl -k).");
          } else if (process.env.ARGOCD_CA_CERT) {
            let cert = process.env.ARGOCD_CA_CERT;
            if (cert.includes('\\n')) cert = cert.replace(/\\n/g, '\n');
            fs.writeFileSync('/tmp/argocd-ca.crt', cert);
            curlSslFlags = "--cacert /tmp/argocd-ca.crt";
            core.info("‚úÖ Using provided CA cert with curl.");
          }

          let finalToken = process.env.TOKEN;
          if (process.env.MODE !== "token") {
            const body = JSON.stringify({ username: process.env.USERNAME, password: process.env.PASSWORD });
            const cmd = `curl -s ${curlSslFlags} -X POST "${argocdUrl}/api/v1/session" -H "Content-Type: application/json" -d '${body.replace(/'/g,"'\\''")}'`;
            const resp = execSync(cmd).toString();
            try {
              finalToken = JSON.parse(resp).token;
            } catch {
              core.error(`Response: ${resp}`);
              core.setFailed("‚ùå Failed to parse ArgoCD session response");
              return;
            }
          }
          if (!finalToken) {
            core.setFailed("‚ùå Failed to obtain ArgoCD token.");
            return;
          }
          core.info("‚úÖ Successfully obtained ArgoCD token.");
          core.setOutput('argocd_url', argocdUrl);
          core.setOutput('curl_ssl_flags', curlSslFlags);
          core.setOutput('token', finalToken);

    - name: Delete ArgoCD apps (per app)
      if: ${{ inputs.delete_first == 'true' || inputs.delete_only == 'true' }}
      uses: actions/github-script@v7
      env:
        APPS: ${{ inputs.apps }}
        ARGOCD_URL: ${{ steps.argocd_conn.outputs.argocd_url }}
        ARGOCD_TOKEN: ${{ steps.argocd_conn.outputs.token }}
        CURL_SSL_FLAGS: ${{ steps.argocd_conn.outputs.curl_ssl_flags }}
        NAMESPACE: ${{ inputs.namespace }}
      with:
        script: |
          const { execSync } = require('child_process');
          const apps = JSON.parse(process.env.APPS || '[]');
          function httpCode(cmd) {
            return parseInt(execSync(`${cmd} -o /dev/null -w "%{http_code}"`).toString().trim(), 10);
          }
          for (const app of apps) {
            const appName = `${process.env.NAMESPACE}-${app.name}`;
            const appUrl = `${process.env.ARGOCD_URL}/api/v1/applications/${appName}`;
            core.info(`üóëÔ∏è Deleting ArgoCD Application: ${appName}`);
            const delCmd = `curl -s ${process.env.CURL_SSL_FLAGS} -X DELETE "${appUrl}" -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" -H "Content-Type: application/json"`;
            const code = httpCode(delCmd);
            core.info(`Delete response HTTP ${code}`);
            if (![200,202,204].includes(code)) {
              core.setFailed(`‚ùå Failed to delete ${appName}: HTTP ${code}`);
              continue;
            }
            const timeout = Date.now() + 120000;
            while (Date.now() < timeout) {
              const checkCmd = `curl -s ${process.env.CURL_SSL_FLAGS} -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" "${appUrl}"`;
              const checkCode = httpCode(checkCmd);
              if (checkCode === 403) {
                core.info(`‚úÖ ${appName} deleted (HTTP 403)`);
                break;
              }
              core.info(`‚è≥ Still deleting ${appName} (HTTP ${checkCode})...`);
              await new Promise(r => setTimeout(r, 5000));
            }
          }

    - name: Check or create ArgoCD applications (per app)
      uses: actions/github-script@v7
      if: ${{ inputs.delete_only == 'false' }}
      env:
        ACTIONS_STEP_DEBUG: true
        APPS: ${{ inputs.apps }}
        CD_PATH_REL: ${{ inputs.cd_path_rel }} 
        OVERLAY_DIR: ${{ inputs.overlay_dir }}
        CD_REPO: ${{ inputs.cd_repo }}
        CD_REPO_ORG: ${{ inputs.cd_repo_org }}
        ARGOCD_URL: ${{ steps.argocd_conn.outputs.argocd_url }}
        ARGOCD_TOKEN: ${{ steps.argocd_conn.outputs.token }}
        CURL_SSL_FLAGS: ${{ steps.argocd_conn.outputs.curl_ssl_flags }}
        NAMESPACE: ${{ inputs.namespace }}
        TEMPLATE_FILE: ${{ github.action_path }}/templates/argocd-app-template-v6.json
      with:
        script: |
          const { execSync } = require('child_process');
          const fs = require('fs');
          const path = require('path');
          core.info(`GITHUB_ACTION_PATH=${process.env.GITHUB_ACTION_PATH || 'undefined'}`);
          require(path.join(process.env.GITHUB_ACTION_PATH, 'nunjucks.js'))
          const apps = JSON.parse(process.env.APPS || '[]');

          // === Helper functions (same logic, extra debug) ===
          function curlJson(url) {
            const cmd = `curl -s ${process.env.CURL_SSL_FLAGS} -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" "${url}"`;
            core.info(`üîé curlJson executing: ${cmd.replace(process.env.ARGOCD_TOKEN, '<REDACTED>')}`);
            try {
              const result = execSync(cmd).toString();
              core.info(`üì° curlJson response (first 400 chars): ${result.slice(0,400)}${result.length>400?'‚Ä¶':''}`);
              return result;
            } catch (err) {
              core.warning(`‚ö†Ô∏è curlJson failed for ${url}: ${err.message}`);
              return '';
            }
          }

          function deleteApp(appUrl, appName) {
            return new Promise(async (resolve) => {
              const { execSync } = require('child_process');
              const core = require('@actions/core');

              const delCmd = `curl -s -o /dev/null -w "%{http_code}" ${process.env.CURL_SSL_FLAGS} \
                -X DELETE "${appUrl}" -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" \
                -H "Content-Type: application/json"`;
              core.info(`üóëÔ∏è Deleting app ${appName}`);
              execSync(delCmd);

              const timeout = Date.now() + 120000;
              while (Date.now() < timeout) {
                const checkCmd = `curl -s -o /dev/null -w "%{http_code}" ${process.env.CURL_SSL_FLAGS} \
                  -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" "${appUrl}"`;
                const code = parseInt(execSync(checkCmd).toString());
                core.info(`‚åõ Delete check for ${appName}: HTTP ${code}`);
                if (code === 403) {
                  resolve(true);
                  return;
                }
                await new Promise(r => setTimeout(r, 5000)); // ‚úÖ works in github-script
              }

              resolve(false);
            });
          }



          // === Load template ===
          const templatePath = process.env.TEMPLATE_FILE;

          core.info(`üìÇ Loading template: ${templatePath}`);
          const template = fs.readFileSync(templatePath, 'utf8');
          // core.info(`üìú Template content (first 500 chars):\n${template.slice(0,500)}${template.length>500?'‚Ä¶':''}`);

          // === Main processing loop ===
          for (const app of apps) {
            const appName = `${process.env.NAMESPACE}-${app.name}`;
            const statusUrl = `${process.env.ARGOCD_URL}/api/v1/applications/${appName}`;
            const basePath = path.join(process.env.CD_PATH_REL, app.name, 'overlays', process.env.OVERLAY_DIR);

            core.startGroup(`üîß Processing ${appName}`);
            // core.info(`üîç Checking status at: ${statusUrl}`);
            core.info(`üìÅ Base path: ${basePath}`);

            const status = curlJson(statusUrl);
            if (status) {
              try {
                const existing = JSON.parse(status);
                // core.info(`üìÑ Existing app JSON (first 300 chars): ${JSON.stringify(existing).slice(0,300)}${status.length>300?'‚Ä¶':''}`);
                if (existing?.spec?.source?.path !== basePath) {
                  core.warning(`‚ö†Ô∏è Path mismatch for ${appName}, recreating`);
                  deleteApp(statusUrl, appName);
                } else {
                  core.info(`‚úÖ Argo app ${appName} exists with correct path.`);
                  core.endGroup();
                  continue;
                }
              } catch (err) {
                core.warning(`‚ö†Ô∏è Failed to parse ArgoCD app JSON for ${appName}: ${err.message}`);
              }
            }

            // Render manifest
            const rendered = nunjucks.renderString(template, {
              APP_NAME: appName,
              NAMESPACE: process.env.NAMESPACE,
              CD_REPO: process.env.CD_REPO,
              CD_REPO_ORG: process.env.CD_REPO_ORG,
              CD_PATH: basePath
            });
            // core.info(`üß© Rendered ArgoCD manifest (first 800 chars):\n${rendered.slice(0,800)}${rendered.length>800?'‚Ä¶':''}`);

            // Create app
            const postCmd = `curl -s ${process.env.CURL_SSL_FLAGS} -X POST "${process.env.ARGOCD_URL}/api/v1/applications" \
              -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" \
              -H "Content-Type: application/json" \
              -d '${rendered.replace(/'/g,"'\\''")}' -w "\\n%{http_code}"`;
            core.info(`üöÄ Creating app ${appName}`);

            try {
              const output = execSync(postCmd).toString();
              const [responseBody, httpCode] = output.split('\n');
              core.info(`üì° Create response HTTP ${httpCode}`);
              core.info(`üì¶ Response body (first 500 chars): ${responseBody.slice(0,500)}${responseBody.length>500?'‚Ä¶':''}`);
              core.info(`‚úÖ Created Argo app ${appName}`);
            } catch (err) {
              core.warning(`‚ùå curl POST failed for ${appName}: ${err.message}`);
            }

            core.endGroup();
          }



    - name: Sync ArgoCD apps (per app)
      id: sync
      if: ${{ inputs.delete_only == 'false' }}
      uses: actions/github-script@v7
      env:
        ACTIONS_STEP_DEBUG: true
        APPS: ${{ inputs.apps }}
        ARGOCD_URL: ${{ steps.argocd_conn.outputs.argocd_url }}
        ARGOCD_TOKEN: ${{ steps.argocd_conn.outputs.token }}
        CURL_SSL_FLAGS: ${{ steps.argocd_conn.outputs.curl_ssl_flags }}
        NAMESPACE: ${{ inputs.namespace }}
      with:
        script: |
          const { execSync } = require('child_process');
          const apps = JSON.parse(process.env.APPS || '[]');
          const baselines = {};
          for (const app of apps) {
            const appName = `${process.env.NAMESPACE}-${app.name}`;
            const statusUrl = `${process.env.ARGOCD_URL}/api/v1/applications/${appName}`;
            let baseline = 0;
            try {
              const status = execSync(`curl -s ${process.env.CURL_SSL_FLAGS} -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" "${statusUrl}"`).toString();
              const json = JSON.parse(status);
              if (json?.status?.operationState?.startedAt)
                baseline = new Date(json.status.operationState.startedAt).getTime();
            } catch {}
            baselines[appName] = baseline;
            try {
              execSync(`curl -s ${process.env.CURL_SSL_FLAGS} -X POST "${statusUrl}/sync" -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" -H "Content-Type: application/json" -d '{"prune":true,"force":true}'`);
              core.info(`üöÄ Force-prune sync triggered: ${appName}`);
            } catch (err) {
              core.setFailed(`‚ùå Failed to sync ${appName}: ${err.message}`);
            }
          }
          core.setOutput('baselines', JSON.stringify(baselines));


    - name: Wait for ArgoCD sync (per app)
      if: ${{ inputs.skip_status_check == false && inputs.delete_only == false }}
      uses: actions/github-script@v7
      env:
        APPS: ${{ steps.apps.outputs.apps }}
        ARGOCD_URL: ${{ steps.argocd_conn.outputs.argocd_url }}
        ARGOCD_TOKEN: ${{ steps.argocd_conn.outputs.token }}
        CURL_SSL_FLAGS: ${{ steps.argocd_conn.outputs.curl_ssl_flags }}
        NAMESPACE: ${{ inputs.namespace }}
        BASELINES: ${{ steps.sync.outputs.baselines }}
      with:
        result-encoding: string
        script: |
          const { execSync } = require("child_process");
          const apps = JSON.parse(process.env.APPS || "[]");
          const baselines = JSON.parse(process.env.BASELINES || "{}");

          const results = {};  // namespace/app ‚Üí ‚úÖ / ‚ùå

          function allResourcesSynced(json) {
            const results =
              json?.status?.operationState?.syncResult?.resources ||
              json?.status?.operationState?.results ||
              [];
            return (
              Array.isArray(results) &&
              results.length > 0 &&
              results.every(r => r.status === "Synced" || r.hookPhase === "Succeeded")
            );
          }

          for (const app of apps) {
            const appName = `${process.env.NAMESPACE}-${app.name}`;
            const appKey = `${process.env.NAMESPACE}/${app.name}`;
            const statusUrl = `${process.env.ARGOCD_URL}/api/v1/applications/${appName}`;
            const baseline = baselines[appName] || 0;
            core.startGroup(`‚è≥ Waiting for sync of ${appName}, baseline=${baseline}`);

            let ok = false;
            let lastPhase, lastSync, lastHealth;
            let consecutiveErrors = 0;

            try {
              for (let i = 0; i < 36; i++) {
                try {
                  const status = execSync(
                    `curl -s ${process.env.CURL_SSL_FLAGS} -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" "${statusUrl}"`
                  ).toString();
                  const json = JSON.parse(status);

                  const op = json?.status?.operationState;
                  lastPhase = op?.phase;
                  lastSync = json?.status?.sync?.status;
                  lastHealth = json?.status?.health?.status;

                  core.info(
                    `üîÑ Iteration ${i + 1}/36 for ${appName}: phase=${lastPhase}, sync=${lastSync}, health=${lastHealth}`
                  );

                  consecutiveErrors = 0; // reset if success

                  // Immediate fail conditions
                  if (lastPhase === "Error" || lastSync === "Error" || lastSync === "Failed") {
                    core.setFailed(`‚ùå Sync failed for ${appName} (phase=${lastPhase}, sync=${lastSync})`);
                    results[appKey] = "‚ùå";
                    throw new Error("stop"); // break out entirely
                  }

                  const startedAt = op?.startedAt ? new Date(op.startedAt).getTime() : 0;
                  const allSynced = allResourcesSynced(json);

                  if (startedAt > baseline) {
                    if (lastHealth === "Degraded") {
                      core.setFailed(`‚ùå ${appName} is Synced but health=Degraded.`);
                      results[appKey] = "‚ùå";
                      throw new Error("stop");
                    }
                    if (lastPhase === "Succeeded" && lastSync === "Synced" && lastHealth === "Healthy") {
                      core.info(`‚úÖ ${appName} synced after baseline and is Healthy.`);
                      ok = true;
                      break;
                    } else if (allSynced && lastHealth === "Healthy") {
                      core.info(`‚úÖ ${appName} has all synced results and is Healthy.`);
                      ok = true;
                      break;
                    } else if (lastSync === "Synced") {
                      core.info(`‚è≥ ${appName} is Synced but health=${lastHealth} ‚Üí waiting for Healthy...`);
                    }
                  }

                  if (startedAt <= baseline) {
                    if (lastSync === "Synced" && lastHealth === "Healthy") {
                      core.info(`‚úÖ ${appName} was already Synced and Healthy before baseline.`);
                      ok = true;
                      break;
                    }
                  }
                } catch (err) {
                  consecutiveErrors++;
                  if (consecutiveErrors > 3) {
                    core.setFailed(
                      `‚ùå Failed to fetch status for ${appName} after ${consecutiveErrors} attempts: ${err.message}`
                    );
                    results[appKey] = "‚ùå";
                    throw new Error("stop");
                  } else {
                    core.warning(
                      `‚ö†Ô∏è Failed to fetch status for ${appName} (attempt ${consecutiveErrors}): ${err.message}`
                    );
                  }
                }
                await new Promise(r => setTimeout(r, 10000));
              }

              if (!ok) {
                core.setFailed(
                  `‚ùå Sync did not complete in time for ${appName} (last phase=${lastPhase}, sync=${lastSync}, health=${lastHealth})`
                );
                results[appKey] = "‚ùå";
              } else {
                results[appKey] = "‚úÖ";
              }
            } catch (fatal) {
              if (fatal.message === "stop") {
                core.endGroup();
                break; // stop checking other apps after first fatal error
              }
            }

            core.endGroup();
          }

          // --- Summary Section ---
          const table = [["Namespace/App", "Synced"]];
          for (const [k, v] of Object.entries(results)) table.push([k, v]);
          core.summary
            .addHeading("üìä ArgoCD Sync Summary")
            .addTable(table)
            .write();

          core.info(`üìã Raw results: ${JSON.stringify(results, null, 2)}`);

